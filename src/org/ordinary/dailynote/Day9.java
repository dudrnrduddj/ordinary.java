package org.ordinary.dailynote;

public class Day9 {

// 1. 캡슐화 - private
//		   - setter, getter
// 	- private변수와, setter, getter 메서드
//	생성한 객체의 멤버에 접근하여 필드값을 변경 하는 것 보다는 private을 활용하여 필드를 선언해주고
//	외부에서 접근할때는 getter로 데이터를 출력, setter로 데이터를 변경할 수 있도록 하는 것이 보안면에서
//	더 훌륭하다고 할 수 있다. 
//	
// 2. 상속
//	
//	2-1 - 기본개념
//	extends를 이용하여 부모 자식관계를 만들어 줄 수 있다.(단, IS-A관계여야함)
//	상속을 시켰다면 자식 인스턴스에서 부모 멤버에 접근이 가능하다.
//	
//	2-2 - 상속에서의 생성자 함수
//	생성자함수의 경우 부모생성자함수가 먼저 호출되고 이후 자식 생성자가 호출된다.
//	자식 생성자에서 super();를 쓰지 않아도 기본생성자로 super();가 호출된다. 
//	하지만 만약 부모생성자에 기본생성자가 없고 매개변수를 가지는 생성자만 있다면 반드시 자식 생성자에서
//	super(datatype variable)을 명시적으로 호출해주어야 한다.
//	또 만약 상위클래스에서 기본생성자, 매개변수생성자가 존재한다면 하위클래스에서는 입맛대로 고를수가 있게된다.
//	하위생성자 안에서 아무것도 명시하지않으면 super();가 알아서 호출될 것이고, 명시적으로 매개변수가 있는 생성자를
//	호출시키면 그것이 호출되게 되어있다.
//	-> 결론적으로 상위에 기본 생성자 없고 매개변수 생성자만 있으면? 반드시 하위에서 명시적으로 super(매개변수) 젤 먼저
//	   호출시켜주기!
//	-> 놓치기 쉬운 점은 부모에 기본생성자가 있음에도 불구하고 하위클래스에서 super()가 명시적으로 쓰여있지 않았을때
//	   이때 부모생성자가 먼저 호출된다는 점을 놓치고 가기 쉽다.
//	   항상 기억해 둘 점은 부모생성자가 먼저 호출되고 자식 생성자가 호출된다는 점이다.
//	
//	2-3 - 메모리구조
//	자식 클래스의 객체를 생성할 때, 먼저 부모 클래스의 객체가 생성된다.
//	자식 클래스의 객체는 부모 클래스의 객체를 포함하는 형태로 메모리에 할당됩니다.
//	-> 자신 객체를 넘어서 부모 객체를 포함하는 영역의 공간이 형성됨
//	
//	
// 3. protected
//	
//	public은 모든 범위에서 접근 가능
//	private은 클래스 내부에서만 접근 가능
//  default는 같은 패키지 내에서 접근 가능
//	-> protected는 같은 패키지 내에서는 default와 같은 형태, 상속관계에서는 super키워드를 통한 접근이
//	가능한 점에서 default와 public의 중간 특징을 띄고 있다.
//	단, 주의해야 할 점은 다른패키지라면 반드시 객체를 통한(instance.) 접근이 아니라 super 키워드(super.)를 이용해야
//	접근이 가능하다. 같은 패키지라면 객체를 통한 접근또한 가능해진다.
//	-> 같은 패키지에서는 default와 같이 접근 제한이 없지만,
//	   다른 패키지에서는 자식 클래스만 접근을 허용한다.(super)
//	
//	
// 4. overloading, overriding
//	
//	4-1 - overloading 
//	 	이름은 똑같으나 매개변수의 개수나 타입이 달라야 적용된다.
//		ex) System.out.println();
//	
//	4-2 - overriding
//		오버라이딩은 상속관계에서 사용
//		접근제한자, 반환형, 메소드명, 매개변수 개수, 타입 모두 동일
//		실행문장만 재정의 하는 것
//		오버라이딩이 되면 동적 바인딩이 되어 다형성을 이용할 수 있음.
//	
//	- 동적 바인딩이란?
//	먼저 메모리 구조에대해서 알아보면
//	객체를 생성할때 멤버변수의 경우 힙메모리에 각각의 인스턴스에 해당하는 공간에 값들이 저장이 된다.
//	하지만 메서드의 경우 메서드영역에 한번 생성이 되어 이를 각각의 인스턴스들이 참조하는 식으로 이루어져 있다.
//	따라서 인스턴스가 달라도 결국 동일한 메서드를 호출하는 것이다.
//	
//	하지만 가상 메서드의 경우에 가상메서드 테이블이 따로 만들어져 각각의 인스턴스에 해당하는 메서드를 갖는 공간을
//	얻게 된다. 이 가상메서드테이블엔 각각의 메서드 이름과 실제 메모리주소가 짝을 이루고 있다.
//	따라서 어떤 메서드가 호출되면 이 테이블에서 주소값을 찾아서 해당 메서드의 명령을 수행하게 된다.
//
//	-> 재정의 된 메서드의 경우 새로운 코드셋을 가지고 새로운 메소드영역을 만들게되어 타입이 아닌 인스턴스에따라
//	 재정의된 메서드 영역에 접근하게 되어 호출되는 것이다.(재정의되면 메모리주소와 메서드이름이 짝을 이루어 형성됨)
//	
//	
//	
//	
// 5. upCasting
//	
//	업캐스팅 (묵시적 형변환)
//	 상속관계의 클래스에서 자식클래스는 묵시적형변환으로 데이터타입을 부모클래스로 변환할 수 있다.
//	 ex) Person student = new Stundent();
//	 student는 Student 객체를 생성하되 타입은 Person클래스 이다.
//	 이때 부모생성자인 Person()이 먼저 호출되어 Person클래스의 멤버변수가 힙 메모리에 생성되고
//	 자식생성자인 Student()이 호출되어 멤버변수가 그 아래 생기게 된다.
//	 이때 student는 데이터타입이 Person이기 때문에 선언한 클래스형에 기반하여 멤버변수와 메서드에 접근할 수 있다.
//	 -> 결론적으로 묵시적형변환 시 그 변수로 접근할 수 있는 멤버와 메서드는 부모클래스의 멤버와 메서드 뿐이다.
//	
//	
//
// OverridingExam.java
//	- 동적바인딩은 super.method()에서는 적용되지 않는 얘기다.
//	- super는 부모 클래스를 참조하기때문에 이가 우선이 된다고 생각하면될듯?


}



