package org.ordinary.dailynote;

public class Day10 {
//	Day10 - 다운캐스팅, instanceof, 추상클래스, 인터페이스
//
//	1. 다운캐스팅
//		상속관계인 경우에 업캐스팅 하여 객체를 생성했을때 타입에 해당하는 멤버에만 접근이 가능하게 되는데
//		이 때 생성한 객체의 멤버에 접근하기를 원한다면 다운캐스팅을 해주어야 한다.
//		Parent p = new Child(); -> 업캐스팅
//		Child c = (Child)p; -> 다운캐스팅
//		다운캐스팅된 c는 Child클래스의 멤버에 접근이 가능하게 된다.
//		아래와 같이 변수를 초기화하지 않고 사용해도 됨
//		System.out.println(((Student)p).department); 
//		
//	2. 	instanceof
//		instanceof 연산자를 사용하여 객체가 실제로 어떤 클래스의 인스턴스인지 확인하는 것은 상속 계층 구조에서 객체의 타입을 판별할 때 매우 유용합니다.
//		특히, 객체의 실제 타입에 따라 다르게 처리해야 하는 상황에서 적절히 사용하면 유용합니다.
//		예를 들어, 다형성을 활용하는 코드에서 특정 타입의 객체에 대해 별도의 로직을 적용할 수 있습니다.
//		만약 객체의 실제 타입이 검사할 클래스와 같거나, 객체의 클래스가 검사할 클래스의 서브클래스라면, instanceof 연산자는 true를 반환합니다.
//		
//	3. 추상클래스 abstract
//		abstract class는 abstract method와 멤버변수를 갖는다.
//		abstract class를 상속받은 클래스에서 오버라이딩을 하지 않았다면 abstract예약어를 붙여줘야한다.
//		최종적으로 생성할 수 있는 클래스는 abstract클래스를 최종적으로 상속받아 구현이 완료된 클래스가 된다.
//		
//		추상클래스는 타입으로 지정할 수 있지만 객체를 생성할 순 없다.
//		
//		추상클래스의 용도는 설계와 구현을 나눌 수 있다는 점이다.
//		슈퍼클래스에서는 개념을, 각 서브클래스에서는 구체적 행위를 구현한다.
//		또 계층적 상속관계를 갖는 클래스 구조를 만들때 이용한다.
//		
//	4. 인터페이스
//		필드(멤버변수) 선언이 불가하지만 final상수는 가능하다.단, public final만 가능
//		추상메소드, default메소드, private메소드, static 메소드로 구성할 수 있다
//		
//		추상메소드 -> public abstract 생략 가능
//		default 메소드 -> 일반 메소드와 같이 오버라이딩 하지않아도되며 상속됨. 구현까지 가능.
//			단, 두 클래스에서 defualt메소드가 중복되고 이 두클래스를 다중상속받는 클래스는 
//			반드시 그 default메소드를 오버라이딩 시켜줘야 오류를 피할 수 있다.
//			
//		static 메소드 -> 인스턴스화 하지 않아도 인터페이스 레벨에서 접근이 가능하다.
//		
//		private 메소드 -> 인터페이스 내부에서 사용하는 메소드이다. private static은 static메소드 내부에서
//						사용 가능하다.
//		
//		인터페이스는 다중 구현이 가능하다. ex) A implements B, C{}
//		이 때 각각의 타입으로 객체를 생성하면 그 타입의 멤버에만 접근이 가능하다.
//		B a = new A();  C a = new A();
//		
//		인터페이스를 인터페이스로 상속이 가능하다.
//		interface B{}
//		interface A extends B, C{}
//		단, B,C의 메소드 모두 오버라이딩 해줘야함.
//		
//		인터페이스 구현과 (추상)클래스 상속을 함께 사용할 수 있다.
//		A extends B implements C{}
//		반드시 extends가 먼저오고 implements가 나중에 와야한다.
	
}

